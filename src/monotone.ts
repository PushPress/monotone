import { createPool, Pool, PoolOptions } from 'mysql2/promise';
import { Logger } from './logger';
import { GTIDReplicaSelector } from './replica-selector';

/**
 * Interface for providing GTID (Global Transaction Identifier) functionality.
 *
 * This interface allows applications to control how GTIDs are retrieved and stored,
 * enabling custom caching strategies, external storage, and performance optimizations.
 *
 * @example
 * ```typescript
 * // Simple implementation - no GTID capture
 * const gtidProvider: GTIDProvider = {
 *   async getGTID() {
 *     const [rows] = await primary.query('SELECT @@GLOBAL.GTID_EXECUTED as gtid');
 *     return rows[0]?.gtid;
 *   }
 * };
 *
 * // Advanced implementation with caching
 * const cachedGTIDProvider: GTIDProvider = {
 *   async getGTID() {
 *     return await redis.get('last-gtid');
 *   },
 *   async onWriteGTID(gtid: string) {
 *     await redis.set('last-gtid', gtid);
 *   }
 * };
 * ```
 */
export interface GTIDProvider {
  /**
   * Retrieves the current GTID for replica synchronization checks.
   *
   * This method is called before read operations to determine which GTID
   * the replicas should be synchronized with. The returned GTID is used
   * to ensure read consistency across primary and replica databases.
   *
   * @param affectedTables - Optional array of table names that may be relevant
   *                        for GTID retrieval. Can be used for table-specific
   *                        GTID strategies or filtering.
   * @returns The GTID string to use for replica synchronization, or
   *          undefined if no GTID is available.
   *
   * @example
   * ```typescript
   * // Basic implementation
   * async getGTID() {
   *   const [rows] = await db.query('SELECT @@GLOBAL.GTID_EXECUTED as gtid');
   *   return rows[0]?.gtid;
   * }
   *
   * // Table-specific implementation
   * async getGTID(affectedTables?: string[]) {
   *   if (affectedTables?.includes('users')) {
   *     return await redis.get('users-gtid');
   *   }
   *   return await redis.get('global-gtid');
   * }
   * ```
   */
  getGTID: (affectedTables?: string[]) => Promise<string | undefined>;

  /**
   * Optional callback invoked when a GTID is generated after write operations.
   *
   * This method is called after each write operation to allow the application
   * to capture and store the generated GTID. This enables applications to:
   * - Cache GTIDs for faster subsequent reads
   * - Store GTIDs in external systems (Redis, monitoring, etc.)
   * - Implement custom GTID tracking strategies
   *
   * ⚠️ **IMPORTANT WARNING**: Only rely on this callback if ALL writes to your
   * database go through this Monotone pool. If you have:
   * - Direct database connections bypassing Monotone
   * - Other applications writing to the same database
   * - Background jobs or migrations using separate connections
   * - Any writes that don't go through this pool
   *
   * Then this callback will miss those GTIDs, leading to inconsistent state
   * where your cached GTID is behind the actual database state. In such cases,
   * consider using a different GTID tracking strategy or ensure all writes
   * go through this pool.
   *
   * If this method is not provided, GTID capture is skipped entirely,
   * resulting in zero overhead for applications that don't need GTID control.
   *
   * @param gtid - The GTID that was generated by the write operation
   * @param affectedTables - Optional array of table names that were affected
   *                        by the write operation. Can be used for table-specific
   *                        GTID storage strategies.
   *
   * @example
   * ```typescript
   * // Redis caching
   * async onWriteGTID(gtid: string) {
   *   await redis.set('last-gtid', gtid);
   *   await redis.expire('last-gtid', 3600); // 1 hour TTL
   * }
   *
   * // Table-specific storage
   * async onWriteGTID(gtid: string, affectedTables?: string[]) {
   *   await redis.set('global-gtid', gtid);
   *   if (affectedTables) {
   *     for (const table of affectedTables) {
   *       await redis.set(`gtid:${table}`, gtid);
   *     }
   *   }
   * }
   * ```
   */
  onWriteGTID?: (gtid: string, affectedTables?: string[]) => Promise<void>;
}

/**
 * Configuration options for a Monotone pool
 */
export interface MonotoneOptions {
  logger?: Logger;
  disabled?: boolean;
  primary: PoolOptions;
  timeout?: number;
  replicas: PoolOptions[];
  gtidProvider: GTIDProvider;
}

/**
 * Pre-compiled regex for detecting write operations
 * Matches SQL keywords at the start of the string (after whitespace)
 */
const WRITE_QUERY_REGEX =
  /^\s*(insert|update|delete|replace|create|drop|alter|truncate|lock|unlock|grant|revoke)\b/i;

/**
 * Detect if a SQL query is a write operation
 * Uses a pre-compiled regex for optimal performance
 */
function isWriteQuery(sql: string): boolean {
  return WRITE_QUERY_REGEX.test(sql);
}

/**
 * Create a proxy that routes queries between primary and replica pools
 */
function createPoolProxy({
  primary,
  replicas,
  logger,
  timeout,
  gtidProvider,
}: {
  primary: Pool;
  replicas: Pool[];
  logger?: Logger;
  timeout?: number;
  gtidProvider: GTIDProvider;
}): Pool {
  const state = {
    replicas: [...replicas], // Create a copy to avoid external mutation
  };

  const selector = new GTIDReplicaSelector({
    primary,
    replicas,
    gtidProvider,
    options: {
      logger,
      timeout,
    },
  });

  return new Proxy(primary, {
    get(target, prop, receiver) {
      // only intercept query method
      if (prop !== 'query') {
        return Reflect.get(target, prop, receiver);
      }

      return async function (...args: unknown[]) {
        const sql = args[0] as string;

        if (isWriteQuery(sql)) {
          logger?.debug(
            {
              sql: sql.substring(0, 100) as string,
            },
            'Routing write query to primary',
          );

          const result = await Reflect.apply(
            Reflect.get(target, 'query', receiver) as Pool['query'],
            receiver,
            args,
          );

          // Capture GTID after write operation
          if (gtidProvider.onWriteGTID) {
            await selector.captureGTID();
          }

          return result;
        }
        if (state.replicas.length === 0) {
          logger?.warn('No replicas available, routing read query to primary');
          return Reflect.apply(
            Reflect.get(target, 'query', receiver) as Pool['query'],
            receiver,
            args,
          );
        }

        if (state.replicas.length > 1) {
          logger?.warn(
            'Rotating between read replicas is not supported yet - will only use one replica',
          );
        }

        const selectedReplica = await selector.selectPool();

        return selectedReplica.query(...(args as Parameters<Pool['query']>));
      } as Pool['query'];
    },
  });
}

/**
 * Create a Monotone pool that automatically routes queries between primary and replicas
 */
export const createMonotonePool = (options: MonotoneOptions): Pool => {
  const primary = createPool(options.primary);
  const replicas = options.replicas.map((replicaConfig) =>
    createPool(replicaConfig),
  );

  if (options.disabled) {
    options.logger?.info(
      'Monotone pool is disabled - all queries will go to primary',
    );
    return primary;
  }

  return createPoolProxy({
    primary,
    replicas,
    timeout: options.timeout,
    logger: options.logger,
    gtidProvider: options.gtidProvider,
  });
};
